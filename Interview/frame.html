<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端框架相关 | 个人博客</title>
    <meta name="description" content="个人工作中整理的知识库">
    
    
    <link rel="preload" href="/assets/css/0.styles.c9120bc4.css" as="style"><link rel="preload" href="/assets/js/app.28316916.js" as="script"><link rel="preload" href="/assets/js/3.1b802084.js" as="script"><link rel="prefetch" href="/assets/js/10.dcf85d9a.js"><link rel="prefetch" href="/assets/js/11.b5e94e03.js"><link rel="prefetch" href="/assets/js/12.20a8dee0.js"><link rel="prefetch" href="/assets/js/13.219090b4.js"><link rel="prefetch" href="/assets/js/14.7fd9e762.js"><link rel="prefetch" href="/assets/js/15.a8ab8c62.js"><link rel="prefetch" href="/assets/js/16.d1e9135e.js"><link rel="prefetch" href="/assets/js/17.92b7f34d.js"><link rel="prefetch" href="/assets/js/18.aff41a9a.js"><link rel="prefetch" href="/assets/js/19.329c50b6.js"><link rel="prefetch" href="/assets/js/2.2f6f10e7.js"><link rel="prefetch" href="/assets/js/20.03ac4d5b.js"><link rel="prefetch" href="/assets/js/21.b6061670.js"><link rel="prefetch" href="/assets/js/22.72d35ede.js"><link rel="prefetch" href="/assets/js/4.3df0f09f.js"><link rel="prefetch" href="/assets/js/5.2c5508de.js"><link rel="prefetch" href="/assets/js/6.4b5e7ee3.js"><link rel="prefetch" href="/assets/js/7.42f5b3e0.js"><link rel="prefetch" href="/assets/js/8.4c2a8588.js"><link rel="prefetch" href="/assets/js/9.6bc43511.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c9120bc4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/Front/" class="nav-link">前端</a></div><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/Java/" class="nav-link">Java</a></div><div class="nav-item"><a href="/WebSecurity/" class="nav-link">网络安全</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/Front/" class="nav-link">前端</a></div><div class="nav-item"><a href="/Interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/Java/" class="nav-link">Java</a></div><div class="nav-item"><a href="/WebSecurity/" class="nav-link">网络安全</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/Interview/" aria-current="page" class="sidebar-link">页面说明</a></li><li><a href="/Interview/js.html" class="sidebar-link">JS面试题</a></li><li><a href="/Interview/html.html" class="sidebar-link">HTML相关</a></li><li><a href="/Interview/css.html" class="sidebar-link">CSS面试题</a></li><li><a href="/Interview/coreCode.html" class="sidebar-link">手写源码系列</a></li><li><a href="/Interview/browser.html" class="sidebar-link">浏览器相关</a></li><li><a href="/Interview/frame.html" aria-current="page" class="active sidebar-link">前端框架相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Interview/frame.html#jquery源码模拟" class="sidebar-link">jQuery源码模拟</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#vdom是什么？为何会存在vdom" class="sidebar-link">vdom是什么？为何会存在vdom?</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#介绍一下diff算法？" class="sidebar-link">介绍一下diff算法？</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#比较react和vue" class="sidebar-link">比较React和Vue</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#redux" class="sidebar-link">Redux</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#说说vue组件间通信方式" class="sidebar-link">说说Vue组件间通信方式</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#vuex的状态管理机制" class="sidebar-link">Vuex的状态管理机制</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#说说vue的mvvm的实现原理" class="sidebar-link">说说Vue的MVVM的实现原理</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#_30道vue面试题" class="sidebar-link">30道Vue面试题</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#请你详细介绍一些-package-json-里面的配置" class="sidebar-link">请你详细介绍一些 package.json 里面的配置</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#webpack的基本配置" class="sidebar-link">webpack的基本配置</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#为什么说vue是一套渐进式框架" class="sidebar-link">为什么说Vue是一套渐进式框架</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#vue-cli提供的几种脚手架模板有哪些，区别是什么" class="sidebar-link">vue-cli提供的几种脚手架模板有哪些，区别是什么</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#vue计算属性缓存与methods的区别" class="sidebar-link">Vue计算属性缓存与methods的区别</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#axios、fetch与ajax有什么区别" class="sidebar-link">axios、fetch与ajax有什么区别</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#vue中央事件总线的使用" class="sidebar-link">vue中央事件总线的使用</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#批量异步更新与nexttick原理" class="sidebar-link">批量异步更新与nextTick原理</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#说说vue开发命令-npm-run-dev-输入后的执行过程" class="sidebar-link">说说Vue开发命令 npm run dev 输入后的执行过程</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#vue-cli中常用到的加载器有哪些" class="sidebar-link">vue-cli中常用到的加载器有哪些</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#pc端页面刷新时如何实现vuex缓存" class="sidebar-link">pc端页面刷新时如何实现vuex缓存</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#vue组件中的data为什么必须是一个函数" class="sidebar-link">Vue组件中的data为什么必须是一个函数</a></li><li class="sidebar-sub-header"><a href="/Interview/frame.html#vue-模板转render函数和react-jsx转render函数的比较" class="sidebar-link">Vue 模板转render函数和React JSX转render函数的比较</a></li></ul></li><li><a href="/Interview/miApp.html" class="sidebar-link">小程序公众号</a></li><li><a href="/Interview/ts.html" class="sidebar-link">TS面试题</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="前端框架相关"><a href="#前端框架相关" class="header-anchor">#</a> 前端框架相关</h1> <h2 id="jquery源码模拟"><a href="#jquery源码模拟" class="header-anchor">#</a> jQuery源码模拟</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">window</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">jQuery</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">selector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">jQuery<span class="token punctuation">.</span>fn<span class="token punctuation">.</span>init</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  jQuery<span class="token punctuation">.</span>fn <span class="token operator">=</span> jQuery<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">constructor</span><span class="token operator">:</span>jQuery<span class="token punctuation">,</span>
    <span class="token function-variable function">css</span><span class="token operator">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//判断key中是否有'-'</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> arr <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//arr[1] = arr[1].slice(0, 1).toUpperCase() + arr[1].slice(1)</span>
        <span class="token comment">//或者使用另外的方法</span>
        arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        key <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">//alert('css');</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">html</span><span class="token operator">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">'html'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">var</span> init <span class="token operator">=</span> jQuery<span class="token punctuation">.</span>fn<span class="token punctuation">.</span><span class="token function-variable function">init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">selector</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> slice <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">;</span>
    <span class="token keyword">var</span> dom <span class="token operator">=</span> <span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> i<span class="token punctuation">,</span> len <span class="token operator">=</span> dom <span class="token operator">?</span> dom<span class="token punctuation">.</span>length <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dom<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> len<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>selector <span class="token operator">=</span> selector <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  init<span class="token punctuation">.</span>prototype <span class="token operator">=</span> jQuery<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
  window<span class="token punctuation">.</span>jQuery <span class="token operator">=</span> window<span class="token punctuation">.</span>$ <span class="token operator">=</span> jQuery
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span>

<span class="token comment">/*------------------示例------------------*/</span>
<span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>jquery test <span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>jquery test <span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">'div1'</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>jquery test <span class="token keyword">in</span> div<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span> src<span class="token operator">=</span><span class="token string">'my-jquery.js'</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
  <span class="token keyword">var</span> $p <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  $p<span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'font-size'</span><span class="token punctuation">,</span> <span class="token string">'40px'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>$p<span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> $div1 <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#div1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  $div1<span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'color'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>$div1<span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><ul><li>思考：为啥构造函数init的原型要定义jQuery.fn或者$.fn来声明然后赋值，而不直接赋值？
<ol><li>因为只有$或jQuery会暴漏在window全局变量中，构造函数init是不会暴漏出去的，所以要在$或者jQuery上声明一个属性fn来保存原型，以便于扩展</li> <li>将插件扩展统一到$.fn.xxx这一个接口中，方便使用</li></ol></li></ul> <hr> <h2 id="vdom是什么？为何会存在vdom"><a href="#vdom是什么？为何会存在vdom" class="header-anchor">#</a> vdom是什么？为何会存在vdom?</h2> <ul><li>virtual dom(vdom)是虚拟DOM，用JS模拟DOM结构。</li> <li>DOM变化的对比，放在JS层来做，提高重绘性能</li></ul> <hr> <h2 id="介绍一下diff算法？"><a href="#介绍一下diff算法？" class="header-anchor">#</a> 介绍一下diff算法？</h2> <p>相关链接：</p> <ul><li><a href="https://www.jianshu.com/p/3ba0822018cf" target="_blank" rel="noopener noreferrer">React之diff算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://react.iamkasong.com/diff/prepare.html" target="_blank" rel="noopener noreferrer">React技术揭秘--diff算法(卡颂)<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <hr> <h2 id="比较react和vue"><a href="#比较react和vue" class="header-anchor">#</a> 比较React和Vue</h2> <ul><li><p>相同点</p> <ol><li>都有组件化开发和Virtual DOM</li> <li>都支持props进行父子组件间数据通信</li> <li>都支持数据驱动视图，不直接操作真实DOM，更新状态数据界面就会自动更新</li> <li>都支持服务端渲染</li> <li>都有支持native的方案，React的React Native，Vue的Weex</li></ol></li> <li><p>不同点</p> <ol><li>数据绑定：Vue实现了数据的双向绑定， react数据流动是单向的</li> <li>组件写法不一样。React推荐的做法是JSX，也就是把HTML和CSS全都写进JavaScript，即'all in js';Vue推荐的做法是webpack + vue-loader的单文件组件格式，即HTML,CSS,JS卸载同一个文件</li> <li>state对象在react应用中不可变的，需要用setState方法更新状态；在vue中，state对象不是必须的，数据由data属性在vue对象中管理</li> <li>Virtual DOM不一样，vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树；而对React而言，每当应用的状态被改变时，全部组件都会重新渲染，所以React中会需要shouldComponentUpdate这个生命周期函数方法来进行控制</li> <li>React严格上只针对MVC的view层，Vue则是MVVM模式</li></ol></li></ul> <h2 id="redux"><a href="#redux" class="header-anchor">#</a> Redux</h2> <ol><li><p>对Redux基本理解</p> <ol><li>redux是一个独立专门用于做状态管理的JS库，不是react的插件库</li> <li>它可以用在react，angular， vue等项目中，但基本与react配合使用</li> <li>作用：集中式管理react应用中多个组件共享的转台和从后台获取的数据</li></ol></li> <li><p>Redux的工作原理
<img src="/assets/img/redux.979c7f4e.png" alt="Redux"></p></li> <li><p>Redux使用扩展</p> <ol><li>使用react-redux简化redux的编码</li> <li>使用redux-thunk实现redux的异步编码</li> <li>使用Redux DevTools实现chrome中redux的调试</li></ol></li></ol> <h2 id="说说vue组件间通信方式"><a href="#说说vue组件间通信方式" class="header-anchor">#</a> 说说Vue组件间通信方式</h2> <ul><li><p>通信种类</p> <ol><li>父组件向子组件通信</li> <li>子组件向父组件通信</li> <li>隔代组件间通信</li> <li>兄弟组件间通信</li></ol></li> <li><p>实现通信方式</p> <ol><li>props</li> <li>vue 自定义事件</li> <li>消息订阅与发布</li> <li>vuex</li> <li>slot</li></ol></li> <li><p>具体通信方式
1：props
1. 通过一般属性实现父向子通信
2. 通过函数属性实现子向父通信
3. 缺点：隔代组件和兄弟组件间通信比较麻烦</p> <p>2：vue自定义事件
1. vue内置实现，可以代替函数类型的props
* 在父组件中绑定监听：&lt;MyComponent @eventName='callback'&gt;
* 在子组件中触发(分发)事件:this.$emit('eventName', data)
2. 缺点：只适合于子向父通信</p> <p>3：消息订阅与发布
1. 需要引入消息订阅与发布的实现库，如：pubsub-js
* 订阅消息：PubSub.subscribe('msg', (msg, data) =&gt; {})
* 发布消息: PubSub.publish('msg',data)
2. 优点：此方式可实现任意关系组件间通信</p> <p>4：vuex
1. 是什么：vuex是vue官方提供的集中式管理vue多组件共享状态数据的vue插件
2. 优点：对组件间关系没有限制，且相比于pubsub库管理更集中，更方便</p> <p>5：slot
1. 是什么：专门用来实现父向子传递带数据的标签
* 子组件
* 父组件
2. 注意：通信的标签模板是在父组件中解析好后再传递给子组件的</p></li></ul> <hr> <h2 id="vuex的状态管理机制"><a href="#vuex的状态管理机制" class="header-anchor">#</a> Vuex的状态管理机制</h2> <ol><li><p>是什么: Vuex是一个专为Vue.js应用程序开发的状态管理的Vue插件</p></li> <li><p>作用: 集中式管理vue多个组件共享的状态和从后台获取的数据</p></li> <li><p>Vuex的工作原理
<img src="/assets/img/vuex.45b0f09f.png" alt="vuex"></p></li></ol> <hr> <h2 id="说说vue的mvvm的实现原理"><a href="#说说vue的mvvm的实现原理" class="header-anchor">#</a> 说说Vue的MVVM的实现原理</h2> <ol><li>理解
<ul><li>Vue作为MVVM模板的实现库的两种技术
<ol><li>模板解析</li> <li>数据绑定</li></ol></li> <li>模板解析：实现初始化显示
<ol><li>解析大括号表达式</li> <li>解析指令</li></ol></li> <li>数据绑定: 实现更新显示
<ol><li>通过数据劫持实现</li></ol></li></ul></li> <li>原理结构图
<img src="/assets/img/Vue_mvvm.a729fee8.png" alt="VueMVVM"></li></ol> <hr> <h2 id="_30道vue面试题"><a href="#_30道vue面试题" class="header-anchor">#</a> 30道Vue面试题</h2> <h3 id="_1、说说你对-spa-单页面的理解，它的优缺点分别是什么？"><a href="#_1、说说你对-spa-单页面的理解，它的优缺点分别是什么？" class="header-anchor">#</a> 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3> <p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p> <p>优点：</p> <ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li> <li>基于上面一点，SPA 相对对服务器压力小；</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul> <p>缺点：</p> <ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li> <li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul> <hr> <h3 id="_2、v-show-与-v-if-有什么区别？"><a href="#_2、v-show-与-v-if-有什么区别？" class="header-anchor">#</a> 2、v-show 与 v-if 有什么区别？</h3> <ul><li>v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li> <li>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。<br>
所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</li></ul> <hr> <h3 id="_3、class-与-style-如何动态绑定？"><a href="#_3、class-与-style-如何动态绑定？" class="header-anchor">#</a> 3、Class 与 Style 如何动态绑定？</h3> <p>Class 可以通过对象语法和数组语法进行动态绑定：</p> <ul><li>对象语法：<div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token operator">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;{ active: isActive, 'text-danger': hasError }&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">isActive</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">hasError</span><span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>数组语法：<div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token operator">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;[isActive ? activeClass : '', errorClass]&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">activeClass</span><span class="token operator">:</span> <span class="token string">'active'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">errorClass</span><span class="token operator">:</span> <span class="token string">'text-danger'</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <p>Style 也可以通过对象语法和数组语法进行动态绑定：</p> <ul><li><p>对象语法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token operator">:</span>style<span class="token operator">=</span><span class="token string">&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">activeColor</span><span class="token operator">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">fontSize</span><span class="token operator">:</span> <span class="token number">30</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>数组语法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token operator">:</span>style<span class="token operator">=</span><span class="token string">&quot;[styleColor, styleSize]&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">styleColor</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">color</span><span class="token operator">:</span> <span class="token string">'red'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">styleSize</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token literal-property property">fontSize</span><span class="token operator">:</span><span class="token string">'23px'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <hr> <h3 id="_4、怎样理解-vue-的单向数据流？"><a href="#_4、怎样理解-vue-的单向数据流？" class="header-anchor">#</a> 4、怎样理解 Vue 的单向数据流？</h3> <p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p> <p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p> <p>有两种常见的试图改变一个 prop 的情形 :</p> <ul><li><p>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'initialCounter'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">counter</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>initialCounter
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'size'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">normalizedSize</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <hr> <h3 id="_5、computed-和-watch-的区别和运用的场景？"><a href="#_5、computed-和-watch-的区别和运用的场景？" class="header-anchor">#</a> 5、computed 和 watch 的区别和运用的场景？</h3> <p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；<br> <br>
watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br> <br>
运用场景：</p> <ul><li><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p></li> <li><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p></li></ul> <hr> <h3 id="_6、直接给一个数组项赋值，vue-能检测到变化吗？"><a href="#_6、直接给一个数组项赋值，vue-能检测到变化吗？" class="header-anchor">#</a> 6、直接给一个数组项赋值，Vue 能检测到变化吗？</h3> <p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p> <ol><li>当你利用索引直接设置一个数组项时，例如：<font color="red">vm.items[indexOfItem] = newValue</font></li> <li>当你修改数组的长度时，例如：<font color="red">vm.items.length = newLength</font></li></ol> <p>为了解决第一个问题，Vue 提供了以下操作方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Vue.set</span>
Vue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>items<span class="token punctuation">,</span> indexOfItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
<span class="token comment">// vm.$set，Vue.set的一个别名</span>
vm<span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>items<span class="token punctuation">,</span> indexOfItem<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
<span class="token comment">// Array.prototype.splice</span>
vm<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>indexOfItem<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> newValue<span class="token punctuation">)</span>
</code></pre></div><p>为了解决第二个问题，Vue 提供了以下操作方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Array.prototype.splice</span>
vm<span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>newLength<span class="token punctuation">)</span>
</code></pre></div><hr> <h3 id="_7、谈谈你对-vue-生命周期的理解？"><a href="#_7、谈谈你对-vue-生命周期的理解？" class="header-anchor">#</a> 7、谈谈你对 Vue 生命周期的理解？</h3> <ol><li><p>生命周期是什么？
Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p></li> <li><p>各个生命周期的作用</p></li></ol> <table><thead><tr><th>生命周期</th> <th>描述</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>组件实例被创建之初，组件的属性生效之前</td></tr> <tr><td>created</td> <td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr> <tr><td>beforeMount</td> <td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr> <tr><td>mounted</td> <td>el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr> <tr><td>beforeUpdate</td> <td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr> <tr><td>update</td> <td>组件数据更新之后</td></tr> <tr><td>activited</td> <td>keep-alive专属，组件被激活时调用</td></tr> <tr><td>deactivated</td> <td>keep-alive专属，组件被销毁时调用</td></tr> <tr><td>beforeDestory</td> <td>组件销毁前调用</td></tr> <tr><td>destoryed</td> <td>组件销毁后调用</td></tr></tbody></table> <ol start="3"><li>生命周期示意图
<img src="/assets/img/Vue-lifeCycle.e70c6faa.png" alt="Vue-lifeCycle"></li></ol> <hr> <h3 id="_8、vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#_8、vue-的父组件和子组件生命周期钩子函数执行顺序？" class="header-anchor">#</a> 8、Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3> <p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p> <ul><li><p>加载渲染过程<br>
父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p></li> <li><p>子组件更新过程<br>
父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p></li> <li><p>父组件更新过程<br>
父 beforeUpdate -&gt; 父 updated</p></li> <li><p>销毁过程<br>
父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></li></ul> <hr> <h3 id="_9、在哪个生命周期内调用异步请求？"><a href="#_9、在哪个生命周期内调用异步请求？" class="header-anchor">#</a> 9、在哪个生命周期内调用异步请求？</h3> <p>可以在钩子函数 <font color="red">created、beforeMount、mounted </font>中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p> <ul><li>能更快获取到服务端数据，减少页面 loading 时间；</li> <li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul> <hr> <h3 id="_10、在什么阶段才能访问操作dom？"><a href="#_10、在什么阶段才能访问操作dom？" class="header-anchor">#</a> 10、在什么阶段才能访问操作DOM？</h3> <p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。
<img src="/assets/img/Vue-lifeCycle.e70c6faa.png" alt="Vue-lifeCycle"></p> <hr> <h3 id="_11、父组件可以监听到子组件的生命周期吗？"><a href="#_11、父组件可以监听到子组件的生命周期吗？" class="header-anchor">#</a> 11、父组件可以监听到子组件的生命周期吗？</h3> <p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Parent.vue</span>
<span class="token operator">&lt;</span>Child @mounted<span class="token operator">=</span><span class="token string">&quot;doSomething&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span> 
<span class="token comment">// Child.vue</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&quot;mounted&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  Parent.vue</span>
<span class="token operator">&lt;</span>Child @hook<span class="token operator">:</span>mounted<span class="token operator">=</span><span class="token string">&quot;doSomething&quot;</span> <span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>
<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'父组件监听到 mounted 钩子函数 ...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>  
<span class="token comment">//  Child.vue</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'子组件触发 mounted 钩子函数 ...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>    
    
<span class="token comment">// 以上输出顺序为：</span>
<span class="token comment">// 子组件触发 mounted 钩子函数 ...</span>
<span class="token comment">// 父组件监听到 mounted 钩子函数 ...     </span>
</code></pre></div><p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p> <hr> <h3 id="_12、谈谈你对-keep-alive-的了解？"><a href="#_12、谈谈你对-keep-alive-的了解？" class="header-anchor">#</a> 12、谈谈你对 keep-alive 的了解？</h3> <p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p> <ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li> <li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li> <li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul> <hr> <h3 id="_13、组件中-data-为什么是一个函数？"><a href="#_13、组件中-data-为什么是一个函数？" class="header-anchor">#</a> 13、组件中 data 为什么是一个函数？</h3> <blockquote><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// data</span>
<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">&quot;子组件&quot;</span><span class="token punctuation">,</span>
	<span class="token literal-property property">childName</span><span class="token operator">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// new Vue</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  router<span class="token punctuation">,</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'&lt;App/&gt;'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>App<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p> <hr> <h3 id="_14、v-model-的原理？"><a href="#_14、v-model-的原理？" class="header-anchor">#</a> 14、v-model 的原理？</h3> <p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p> <ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li> <li>checkbox 和 radio 使用 checked 属性和 change 事件；</li> <li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul> <p>以 input 表单元素为例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">'something'</span><span class="token operator">&gt;</span>
    
相当于

<span class="token operator">&lt;</span>input v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;something&quot;</span> v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;something = $event.target.value&quot;</span><span class="token operator">&gt;</span>

</code></pre></div><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p> <div class="language-JS extra-class"><pre class="language-js"><code>父组件：
<span class="token operator">&lt;</span>ModelChild v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;message&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>ModelChild<span class="token operator">&gt;</span>

子组件：
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token literal-property property">props</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> String
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token string">'小红'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><hr> <h3 id="_15、vue-组件间通信有哪几种方式？"><a href="#_15、vue-组件间通信有哪几种方式？" class="header-anchor">#</a> 15、Vue 组件间通信有哪几种方式？</h3> <p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p> <ol><li><p>props / $emit  适用 父子组件通信<br>
这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p></li> <li><p>ref 与 $parent / $children 适用 父子组件通信</p> <ul><li>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li> <li>$parent / $children：访问父 / 子实例</li></ul></li> <li><p>EventBus （$emit / $on）  适用于 父子、隔代、兄弟组件通信<br>
这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p></li> <li><p>$attrs/$listeners 适用于 隔代组件通信</p> <ul><li>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li> <li>$listeners：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件</li></ul></li> <li><p>provide / inject 适用于 隔代组件通信<br>
祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。<br>
provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p></li> <li><p>Vuex  适用于 父子、隔代、兄弟组件通信<br>
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<br>
Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>
改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p></li></ol> <hr> <h3 id="_16、你使用过-vuex-吗？"><a href="#_16、你使用过-vuex-吗？" class="header-anchor">#</a> 16、你使用过 Vuex 吗？</h3> <ul><li><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p> <ol><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li> <li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ol></li> <li><p>主要包括以下几个模块：</p> <ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li> <li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li> <li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li> <li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li> <li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul></li></ul> <hr> <h3 id="_17、使用过-vue-ssr-吗？说说-ssr？"><a href="#_17、使用过-vue-ssr-吗？说说-ssr？" class="header-anchor">#</a> 17、使用过 Vue SSR 吗？说说 SSR？</h3> <blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。<br>
即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p></blockquote> <p>服务端渲染 SSR 的优缺点如下：</p> <ol><li><p>服务端渲染的优点：</p> <ul><li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li> <li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul></li> <li><p>服务端渲染的缺点：</p> <ul><li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li> <li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul></li></ol> <p>如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章<a href="https://juejin.im/post/5cb6c36e6fb9a068af37aa35" target="_blank" rel="noopener noreferrer">《Vue SSR 踩坑之旅》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，里面 SSR 项目搭建以及附有项目源码。</p> <hr> <h3 id="_18、vue-router-路由模式有几种？"><a href="#_18、vue-router-路由模式有几种？" class="header-anchor">#</a> 18、vue-router 路由模式有几种？</h3> <p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">'history'</span><span class="token operator">:</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTML5History</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
  <span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'hash'</span><span class="token operator">:</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallback<span class="token punctuation">)</span>
  <span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'abstract'</span><span class="token operator">:</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbstractHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
  <span class="token keyword">break</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">invalid mode: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中，3 种路由模式的说明如下：</p> <ul><li>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li> <li>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li> <li>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul> <hr> <h3 id="_19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#_19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="header-anchor">#</a> 19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3> <ol><li>hash 模式的实现原理
早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">https</span><span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>word<span class="token punctuation">.</span>com#search
</code></pre></div><p>hash 路由模式的实现主要是基于下面几个特性：</p> <ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li> <li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li> <li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li> <li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul> <ol start="2"><li>history 模式的实现原理
HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">replaceState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>history 路由模式的实现主要基于存在下面几个特性：</p> <ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li> <li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li> <li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul> <hr> <h3 id="_20、什么是-mvvm？"><a href="#_20、什么是-mvvm？" class="header-anchor">#</a> 20、什么是 MVVM？</h3> <p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表</p> <p>MVVM 源自于经典的 Model–View–Controller（MVC）模式  ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：
<img src="/assets/img/MVC.fc2068d2.png" alt="MVC"></p> <ol><li>View 层<br>
View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</li> <li>Model 层<br>
Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</li> <li>ViewModel 层<br>
ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。<br>
需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</li></ol> <p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p> <p>我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：</p> <ol><li>View 层</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>button v<span class="token operator">-</span>on<span class="token operator">:</span>click<span class="token operator">=</span><span class="token string">&quot;showMessage()&quot;</span><span class="token operator">&gt;</span>Click me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div><ol start="2"><li>ViewModel 层</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">el</span><span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 用于描述视图状态   </span>
      <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">'Hello Vue!'</span><span class="token punctuation">,</span> 
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 用于描述视图行为  </span>
      <span class="token function">showMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
          <span class="token function">alert</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
      <span class="token comment">// Ajax 获取 Model 层的数据</span>
      <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'/your/server/data/api'</span><span class="token punctuation">,</span>
          <span class="token function">success</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
              vm<span class="token punctuation">.</span>message <span class="token operator">=</span> res<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li>Model 层</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token string-property property">&quot;url&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/your/server/data/api&quot;</span><span class="token punctuation">,</span>
  <span class="token string-property property">&quot;res&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string-property property">&quot;success&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token string-property property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;IoveC&quot;</span><span class="token punctuation">,</span>
      <span class="token string-property property">&quot;domain&quot;</span><span class="token operator">:</span> <span class="token string">&quot;www.cnblogs.com&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h3 id="_21、vue-是如何实现数据双向绑定的？"><a href="#_21、vue-是如何实现数据双向绑定的？" class="header-anchor">#</a> 21、Vue 是如何实现数据双向绑定的？</h3> <p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：
<img src="data:image/png;base64,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" alt="ViewModel">
即：</p> <ul><li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li> <li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li></ul> <p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p> <p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p> <ol><li><p>实现一个<font color="red"> 监听器 Observer</font>：对数据对象进行遍历，包括子属性对象的属性，利用 <font color="red"> Object.defineProperty() </font>对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会<font color="red"> 触发 setter</font>，那么就能监听到了数据变化。</p></li> <li><p>实现一个<font color="red"> 订阅器 Dep</font>：订阅器采用 发布-订阅 设计模式，用来<font color="red">收集订阅者 Watcher</font>，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p></li> <li><p>实现一个<font color="red"> 解析器 Compile</font>：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，<font color="red">添加监听数据的订阅者 Watcher</font>，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p></li> <li><p>实现一个<font color="red"> 订阅者 Watcher</font>：<font color="red">Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁</font>，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，<font color="red">触发解析器 Compile 中对应的更新函数</font>。</p></li></ol> <p>以上四个步骤的流程图表示如下:
<img src="/assets/img/VueDataView.25a7e44d.png" alt="ViewModel"></p> <p>如果有理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章<a href="https://juejin.im/post/5d421bcf6fb9a06af23853f1" target="_blank" rel="noopener noreferrer">《0 到 1 掌握：Vue 核心之数据双向绑定》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，有进行详细的讲解、以及代码 demo 示例。
<a href="./images/watcher-Dep.png">watcher-Dep.png</a></p> <hr> <h3 id="_22、vue-框架怎么实现对象和数组的监听？"><a href="#_22、vue-框架怎么实现对象和数组的监听？" class="header-anchor">#</a> 22、Vue 框架怎么实现对象和数组的监听？</h3> <p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">/**
 * Observe a list of Array items.
 */</span>
<span class="token function">observeArray</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">items</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// observe 功能为监测数据的变化</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 对属性进行递归遍历
 */</span>
<span class="token keyword">let</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment">// observe 功能为监测数据的变化</span>
</code></pre></div><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p> <hr> <h3 id="_23、proxy-与-object-defineproperty-优劣对比"><a href="#_23、proxy-与-object-defineproperty-优劣对比" class="header-anchor">#</a> 23、Proxy 与 Object.defineProperty 优劣对比</h3> <p>Proxy 的优势如下:</p> <ul><li>Proxy 可以直接监听对象而非属性；</li> <li>Proxy 可以直接监听数组的变化；</li> <li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li> <li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li> <li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul> <p>Object.defineProperty 的优势如下:</p> <ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li></ul> <hr> <h3 id="_24、vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#_24、vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="header-anchor">#</a> 24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h3> <p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 <font color="red"> getter/setter </font>转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了<font color="red"> Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)  </font>来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p> <p>我们查看对应的 Vue 源码：<font color="red"> vue/src/core/instance/index.js </font></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">set</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">target</span><span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> any<span class="token punctuation">,</span> <span class="token literal-property property">val</span><span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>
  <span class="token comment">// target 为数组  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 利用数组的splice变异方法触发响应式  </span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// key 已经存在，直接修改属性值  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token comment">// target 本身就不是响应式数据, 直接赋值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 对属性进行响应式处理</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>

</code></pre></div><p>我们阅读以上源码可知，vm.$set 的实现原理是：
* 如果目标是数组，直接使用数组的 splice 方法触发响应式；
* 如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   <font color="red"> defineReactive </font>方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用<font color="red"> Object.defineProperty </font>动态添加 getter 和 setter 的功能所调用的方法）</p> <hr> <h3 id="_25、虚拟-dom-的优缺点？"><a href="#_25、虚拟-dom-的优缺点？" class="header-anchor">#</a> 25、虚拟 DOM 的优缺点？</h3> <p>优点：</p> <ul><li>保证性能下限：<br>
框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li> <li>无需手动操作 DOM：<br>
我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li> <li>跨平台：<br>
虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul> <p>缺点:</p> <ul><li>无法进行极致优化：
虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul> <hr> <h3 id="_26、虚拟-dom-实现原理？"><a href="#_26、虚拟-dom-实现原理？" class="header-anchor">#</a> 26、虚拟 DOM 实现原理？</h3> <p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p> <ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li> <li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li> <li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul> <p>如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章<a href="https://juejin.im/post/5d36cc575188257aea108a74#heading-14" target="_blank" rel="noopener noreferrer">《深入剖析：Vue核心之虚拟DOM》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>补充：真实DOM和其解析流程
如下图为 webkit 渲染引擎工作流程图
<img src="/assets/img/Dom_render.cc580485.jpg" alt="Dom_render.jpg"></p> <p>所有的浏览器渲染引擎工作流程大致分为5步：创建 <font color="red">DOM 树 </font>—&gt; 创建<font color="red"> Style Rules </font>-&gt; 构建<font color="red"> Render 树 </font>—&gt; 布局<font color="red"> Layout </font>-—&gt; 绘制<font color="red"> Painting </font>。</p> <ol><li>第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；</li> <li>第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；</li> <li>第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；</li> <li>第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；</li> <li>第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。</li></ol> <p>注意点：</p> <ol><li>DOM 树的构建是文档加载完成开始的？ 构建 DOM 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 HTML 文档解析完成之后才开始构建 render 树和布局。</li> <li>Render 树是 DOM 树和 CSS 样式表构建完毕后才开始构建的？ 这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。</li> <li>CSS 的解析注意点？ CSS 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。</li> <li>JS 操作真实 DOM 的代价？ 用我们传统的开发模式，原生 JS 或 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 DOM 节点，浏览器收到第一个 DOM 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。例如，第一次计算完，紧接着下一个 DOM 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 DOM 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 DOM 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验</li></ol> <hr> <h3 id="_27、vue-中的-key-有什么作用？"><a href="#_27、vue-中的-key-有什么作用？" class="header-anchor">#</a> 27、Vue 中的 key 有什么作用？</h3> <p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。<br>
Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和  oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章<a href="https://juejin.im/post/5d36cc575188257aea108a74#heading-14" target="_blank" rel="noopener noreferrer">《深入剖析：Vue核心之虚拟DOM》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p> <p>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</p> <p>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：
```js</p> <pre><code>function createKeyToOldIdx (children, beginIdx, endIdx) {
  let i, key
  const map = {}
  for (i = beginIdx; i &lt;= endIdx; ++i) {
    key = children[i].key
    if (isDef(key)) map[key] = i
  }
  return map
}

```
</code></pre> <hr> <h3 id="_28、你有对-vue-项目进行哪些优化？"><a href="#_28、你有对-vue-项目进行哪些优化？" class="header-anchor">#</a> 28、你有对 Vue 项目进行哪些优化？</h3> <p>如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章<a href="https://juejin.im/post/5d548b83f265da03ab42471d" target="_blank" rel="noopener noreferrer">《 Vue 项目性能优化 — 实践指南 》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。</p> <ol><li>代码层面的优化</li></ol> <pre><code>* v-if 和 v-show 区分使用场景
* computed 和 watch  区分使用场景
* v-for 遍历必须为 item 添加 key，且避免同时使用 v-if
* 长列表性能优化
* 事件的销毁
* 图片资源懒加载
* 路由懒加载
* 第三方插件的按需引入
* 优化无限列表性能
* 服务端渲染 SSR or 预渲染
</code></pre> <ol start="2"><li>Webpack 层面的优化</li></ol> <pre><code>* Webpack 对图片进行压缩
* 减少 ES6 转为 ES5 的冗余代码
* 提取公共代码
* 模板预编译
* 提取组件的 CSS
* 优化 SourceMap
* 构建结果输出分析
* Vue 项目的编译优化
</code></pre> <ol start="3"><li>基础的 Web 技术的优化</li></ol> <pre><code>* 开启 gzip 压缩
* 浏览器缓存
* CDN 的使用
* 使用 Chrome Performance 查找性能瓶颈
</code></pre> <hr> <h3 id="_29、对于即将到来的-vue3-0-特性你有什么了解的吗？"><a href="#_29、对于即将到来的-vue3-0-特性你有什么了解的吗？" class="header-anchor">#</a> 29、对于即将到来的 vue3.0 特性你有什么了解的吗？</h3> <p>Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p> <ol><li><p>监测机制的改变
3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p> <ul><li>只能监测属性，不能监测对象</li> <li>检测属性的添加和删除；</li> <li>检测数组索引和长度的变更；</li> <li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul> <p>新的 observer 还提供了以下特性：</p> <ul><li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li> <li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li> <li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li> <li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li> <li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ul></li> <li><p>模板<br>
模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。<br>
同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p></li> <li><p>对象式的组件声明方式<br>
vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。<br>
此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p></li> <li><p>其它方面的更改<br>
vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p> <ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li> <li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li> <li>基于 treeshaking 优化，提供了更多的内置功能。</li></ul></li></ol> <hr> <h3 id="_30、说说你使用-vue-框架踩过最大的坑是什么？怎么解决的？"><a href="#_30、说说你使用-vue-框架踩过最大的坑是什么？怎么解决的？" class="header-anchor">#</a> 30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？</h3> <p><a href="https://segmentfault.com/a/1190000013008420" target="_blank" rel="noopener noreferrer">VUE使用中踩过的坑<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <hr> <h2 id="请你详细介绍一些-package-json-里面的配置"><a href="#请你详细介绍一些-package-json-里面的配置" class="header-anchor">#</a> 请你详细介绍一些 package.json 里面的配置</h2> <table><thead><tr><th>配置</th> <th>说明</th></tr></thead> <tbody><tr><td>name</td> <td>项目名称</td></tr> <tr><td>version</td> <td>标注了当前项目的版本号</td></tr> <tr><td>description</td> <td>项目描述</td></tr> <tr><td>main</td> <td>main是我们模块或者是项目的入口文件，有且只有一个文件，文件的路径是相对项目的根目录</td></tr> <tr><td>author</td> <td>作者</td></tr> <tr><td>license</td> <td>标注我们项目的许可证权限</td></tr> <tr><td>scripts</td> <td>scripts是npm提供给我们运行shell命令的入口</td></tr> <tr><td>dependencies</td> <td>是项目运行时必要依赖 （如:axios echarts element-ui）</td></tr> <tr><td>devDependencies</td> <td>devDependencies是项目开发时所需依赖 (如:babel-core  css-loader file-loader等)</td></tr></tbody></table> <hr> <h2 id="webpack的基本配置"><a href="#webpack的基本配置" class="header-anchor">#</a> webpack的基本配置</h2> <ul><li>文件目录<br>
-- /node_modules：依赖的各种模块<br>
-- /src<br>
– index.js<br>
– print.js<br>
– style.css<br>
– package.json：配置npm相关设置<br>
– webpack.config.js：配置webpack</li></ul> <p>package.json脚本: npm项目的基本配置，见上文
webpack.config.js:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> CleanWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'clean-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">entry</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">app</span><span class="token operator">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">print</span><span class="token operator">:</span> <span class="token string">'./src/print.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">output</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">filename</span><span class="token operator">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">path</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">module</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">rules</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token literal-property property">test</span><span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        <span class="token literal-property property">use</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token string">'css-loader'</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">devtool</span><span class="token operator">:</span> <span class="token string">'inline-source-map'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">hot</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">contentBase</span><span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">publicPath</span><span class="token operator">:</span> <span class="token string">'/'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>CommonsChunkPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;common&quot;</span><span class="token punctuation">,</span>
      <span class="token literal-property property">minChunks</span><span class="token operator">:</span> <span class="token number">Infinity</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>HotModuleReplacementPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">CleanWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'dist'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'Output Management'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
</code></pre></div><table><thead><tr><th>配置</th> <th>描述</th></tr></thead> <tbody><tr><td>entry</td> <td>入口文件，可配置多文件</td></tr> <tr><td>output</td> <td>输出路径（filename:文件名  path:输出路径）</td></tr> <tr><td>module</td> <td>loaders模块，根据规则应用loader (rules：定义插件使用规则 test:正则匹配 use:使用对应的loader)</td></tr> <tr><td>devtool</td> <td>开发工具</td></tr> <tr><td>devServer</td> <td>开发服务器</td></tr> <tr><td>plugins</td> <td>插件</td></tr></tbody></table> <hr> <h2 id="为什么说vue是一套渐进式框架"><a href="#为什么说vue是一套渐进式框架" class="header-anchor">#</a> 为什么说Vue是一套渐进式框架</h2> <p>Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。</p> <p>如下图所示，这里包含了Vue的所有部件，在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念
<img src="/assets/img/Vue_jianjin.4b457644.png" alt="Vue渐进式"></p> <hr> <h2 id="vue-cli提供的几种脚手架模板有哪些，区别是什么"><a href="#vue-cli提供的几种脚手架模板有哪些，区别是什么" class="header-anchor">#</a> vue-cli提供的几种脚手架模板有哪些，区别是什么</h2> <table><thead><tr><th>模板名称</th> <th>描述</th></tr></thead> <tbody><tr><td>1、webpack：</td> <td>一个全面的 webpack+vue-loader 的模板，功能包括热加载、linting、检测和CSS扩展</td></tr> <tr><td>2、webpack-simple：</td> <td>一个简单 webpack+vue-loader 模板，不包含其他功能，可以快速的搭建 vue 的开发环境</td></tr> <tr><td>3、browserify：</td> <td>一个全面的 Browserify+vueify 模板，功能包括热加载、linting、单元测试</td></tr> <tr><td>4、browserify-simple：</td> <td>一个简单的 Browserify+vueify 模板，不包含其他功能，可以快速的搭建 vue 的开发环境</td></tr> <tr><td>5、simple：</td> <td>一个最简单的单页应用模板</td></tr></tbody></table> <hr> <h2 id="vue计算属性缓存与methods的区别"><a href="#vue计算属性缓存与methods的区别" class="header-anchor">#</a> Vue计算属性缓存与methods的区别</h2> <ol><li>属性对比</li></ol> <table><thead><tr><th>属性</th> <th>页面重新渲染</th> <th>适用场景</th></tr></thead> <tbody><tr><td>computed</td> <td>不变化</td> <td>较大量的计算和改变频率较低的属性</td></tr> <tr><td>methods</td> <td>页面元素的data变化</td> <td>无缓存</td></tr></tbody></table> <ol start="2"><li>总结
<ol><li>同一函数定义为一个方法或是一个计算属性。两种方式的最终结果确实是完全相同的。</li> <li>计算属性是根据依赖自动执行的，methods需要事件调用。
<ul><li>计算属性是基于他们的依赖进行缓存的，只有在相关依赖发生改变时，他们才会重新求值，也就是说，只要他的依赖没有发生变化，那么每次访问的时候计算属性都会立即返回之前的计算结果，不再执行函数</li></ul></li> <li>使用计算属性还是methods取决于是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存。</li></ol></li></ol> <hr> <h2 id="axios、fetch与ajax有什么区别"><a href="#axios、fetch与ajax有什么区别" class="header-anchor">#</a> axios、fetch与ajax有什么区别</h2> <ul><li><p>ajax<br>
传统 Ajax 指的是 XMLHttpRequest（XHR）, 核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。<br>
JQuery ajax 是对原生XHR的封装，除此以外还增添了对JSONP的支持。<br>
优点无需多言；如果是硬要举出几个缺点，那可能只有：</p> <ol><li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li> <li>基于原生的XHR开发，XHR本身的架构不清晰。</li> <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li> <li>不符合关注分离（Separation of Concerns）的原则</li> <li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li></ol></li> <li><p>axios<br>
axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：</p> <ol><li>从浏览器中创建 XMLHttpRequest</li> <li>支持 Promise API</li> <li>客户端支持防止CSRF</li> <li>提供了一些并发请求的接口（重要，方便了很多的操作）</li> <li>从 node.js 创建 http 请求</li> <li>拦截请求和响应</li> <li>转换请求和响应数据</li> <li>取消请求</li> <li>自动转换JSON数据</li></ol></li> <li><p>fecth<br>
fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p> <p>fetch的优点：</p> <ol><li>语法简洁，更加语义化</li> <li>基于标准 Promise 实现，支持 async/await</li> <li>同构方便，使用 <a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" rel="noopener noreferrer">isomorphic-fetch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>更加底层，提供的API丰富（request, response）</li> <li>脱离了XHR，是ES规范里新的实现方式</li></ol> <p>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。缺点如下:</p> <ol><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li> <li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})</li> <li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li> <li>fetch没有办法原生监测请求的进度，而XHR可以</li></ol></li></ul> <hr> <h2 id="vue中央事件总线的使用"><a href="#vue中央事件总线的使用" class="header-anchor">#</a> <a href="https://juejin.im/post/5c9acfc9f265da61246d7124" target="_blank" rel="noopener noreferrer">vue中央事件总线的使用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <blockquote><p>vue中央事件总线这种方法适用于任何情况的父子组件通信，同级别组件通信，相当于组件通信间的万金油。但是碰到多人合作时，代码的维护性较低，代码可读性低（这个缺点可以忽略）。</p></blockquote> <p>第一步：在 src 新建 emit/emit.js，.js文件内容：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> Emit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span><span class="token punctuation">{</span>
    Emit
<span class="token punctuation">}</span>

</code></pre></div><p>第二步：在 src/main.js 下引入</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>Emit<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./emit/emit.js'</span><span class="token punctuation">;</span>
Vue<span class="token punctuation">.</span>proptotype<span class="token punctuation">.</span>Emit <span class="token operator">=</span> Emit<span class="token punctuation">;</span>
</code></pre></div><p>示例：index.vue为父组件，两个子组件 header.vue、footer.vue。</p> <blockquote><p>在mounted生命周期里通过this.Emit.$on()监听。<br> <font color="red">在destroyed生命周期里面通过this.Emit.$off()解除绑定。一定要解除绑定事件！！！</font></p></blockquote> <p>父组件：index.vue</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;indexPageWrap&quot;</span><span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>header<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>header<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>footer<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>footer<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span><span class="token operator">&gt;</span>
   <span class="token keyword">import</span> header <span class="token keyword">from</span> <span class="token string">'./header.vue'</span><span class="token punctuation">;</span>
   <span class="token keyword">import</span> footer <span class="token keyword">from</span> <span class="token string">'./footer.vue'</span><span class="token punctuation">;</span>
    <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
        <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">mounted</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>Emit<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'fromHeader'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>indexFormHeader<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>Emit<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'fromFooter'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>indexFromFooter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment">//注意：在组件销毁时，一定要解除绑定事件：</span>
        <span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>Emit<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token string">'fromHeader'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>Emit<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token string">'fromFooter'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token literal-property property">components</span> <span class="token operator">:</span> <span class="token punctuation">{</span>
        	header<span class="token punctuation">,</span>
        	footer
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token literal-property property">methods</span> <span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token function">indexFormHeader</span><span class="token punctuation">(</span><span class="token parameter">vlaue</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'from header'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token function">indexFromFooter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'from footer'</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>style type<span class="token operator">=</span><span class="token string">&quot;text/css&quot;</span><span class="token operator">&gt;</span>	
<span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">&gt;</span>
</code></pre></div><p>子组件 header.vue</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//子组件 header.vue</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;headerPageWrap&quot;</span><span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>div @click<span class="token operator">=</span><span class="token string">&quot;headerEmit&quot;</span><span class="token operator">&gt;</span>Emit<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span><span class="token operator">&gt;</span>
    <span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
    	<span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    	<span class="token function">mounted</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	    <span class="token keyword">this</span><span class="token punctuation">.</span>Emit<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">'headerTofooter'</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>headerFromFoot<span class="token punctuation">)</span>
    	<span class="token punctuation">}</span><span class="token punctuation">,</span>
    	<span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	    <span class="token keyword">this</span><span class="token punctuation">.</span>Emit<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token string">'headerTofooter'</span><span class="token punctuation">)</span>
    	<span class="token punctuation">}</span><span class="token punctuation">,</span>
    	<span class="token literal-property property">methods</span> <span class="token operator">:</span> <span class="token punctuation">{</span>
    	    <span class="token function">headerEmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            	<span class="token keyword">this</span><span class="token punctuation">.</span>Emit<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'fromHeader'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">value</span><span class="token operator">:</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//可以传递数据</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token function">headerFromFoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'from footer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
    	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>style type<span class="token operator">=</span><span class="token string">&quot;text/css&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">&gt;</span>
</code></pre></div><hr> <h2 id="批量异步更新与nexttick原理"><a href="#批量异步更新与nexttick原理" class="header-anchor">#</a> <a href="https://cloud.tencent.com/developer/article/1356678" target="_blank" rel="noopener noreferrer">批量异步更新与nextTick原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <hr> <h2 id="说说vue开发命令-npm-run-dev-输入后的执行过程"><a href="#说说vue开发命令-npm-run-dev-输入后的执行过程" class="header-anchor">#</a> <a href="https://blog.csdn.net/cerastes/article/details/85065037" target="_blank" rel="noopener noreferrer">说说Vue开发命令 npm run dev 输入后的执行过程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <hr> <h2 id="vue-cli中常用到的加载器有哪些"><a href="#vue-cli中常用到的加载器有哪些" class="header-anchor">#</a> vue-cli中常用到的加载器有哪些</h2> <table><thead><tr><th>名称</th> <th>描述</th></tr></thead> <tbody><tr><td>style-loader</td> <td>将解析的css样式放到style标签下</td></tr> <tr><td>css-loader</td> <td>解析css</td></tr> <tr><td>sass-loader</td> <td>解析sass文件</td></tr> <tr><td>file-loader</td> <td>打包文件</td></tr> <tr><td>url-loader</td> <td>打包文件（小图片会打包成base64）</td></tr> <tr><td>vue-loader</td> <td>解析打包vue文件</td></tr></tbody></table> <hr> <h2 id="pc端页面刷新时如何实现vuex缓存"><a href="#pc端页面刷新时如何实现vuex缓存" class="header-anchor">#</a> <a href="https://www.jianshu.com/p/c2078f6f63b3" target="_blank" rel="noopener noreferrer">pc端页面刷新时如何实现vuex缓存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <ol><li><p>问题描述：<br>
一般在登录成功的时候需要把用户信息，菜单信息放置vuex中，作为全局的共享数据。但是在页面刷新的时候vuex里的数据会重新初始化，导致数据丢失。因为vuex里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载vue实例，vuex里面的数据就会被重新赋值。</p></li> <li><p>解决思路：<br>
办法一：将vuex中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie）<br>
办法二：在页面刷新的时候再次请求远程数据，使之动态更新vuex数据<br>
办法三：在父页面(如App.vue)向后台请求远程数据，使用beforeunload 监听事件在App.vue的created的函数中去监听页面的刷新事件，并且在页面刷新前将vuex的数据先保存至sessionStorage（以防请求数据量过大页面加载时拿不到返回的数据）,当刷新完的时候再取出本地存储数据
分析：<br>
办法一的缺点是不安全，不适用大数据量的存储；每改变一次就会本地存储一次<br>
办法二适用于少量的数据，并且不会出现网络延迟；<br>
办法三是要讲的重点，办法二和办法一一起使用。</p></li></ol> <hr> <h2 id="vue组件中的data为什么必须是一个函数"><a href="#vue组件中的data为什么必须是一个函数" class="header-anchor">#</a> <a href="https://www.jianshu.com/p/f3e774c57356" target="_blank" rel="noopener noreferrer">Vue组件中的data为什么必须是一个函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h2> <p>Vue官方的解答:</p> <blockquote><p>当一个组件被定义， data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！!! 。 而通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。</p></blockquote> <p>其实也很好理解，大概意思就是：</p> <blockquote><p>类比与引用数据类型。如果不用function return 每个组件的data都是内存的同一个地址，那一个数据改变其他也改变了，这当然就不是我们想要的。用function return 其实就相当于申明了新的变量，相互独立，自然就不会有这样的问题；js在赋值object对象时，是直接一个相同的内存地址。所以为了每个组件的data独立，采用了这种方式。<br>
如果不是组件的话，正常data的写法可以直接写一个对象，比如data：{ msg ： ' 下载 ' }，但由于组件是会在多个地方引用的，JS中直接共享对象会造成引用传递，也就是说修改了msg后所有按钮的msg都会跟着修改，所以这里用function来每次返回一个对象实例</p></blockquote> <hr> <h2 id="vue-模板转render函数和react-jsx转render函数的比较"><a href="#vue-模板转render函数和react-jsx转render函数的比较" class="header-anchor">#</a> Vue 模板转render函数和React JSX转render函数的比较</h2> <ol><li>Vue</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//Vue 模板部分</span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;item in list&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span> 
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token comment">//对应的render函数</span>
<span class="token comment">//_c  :createElement函数</span>
<span class="token comment">//_v  :createTextNode函数</span>
<span class="token comment">//_s  :toString函数</span>
<span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span>
    <span class="token string">'div'</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token literal-property property">attr</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string-property property">&quot;id&quot;</span><span class="token operator">:</span><span class="token string">&quot;app&quot;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>
      <span class="token function">_c</span><span class="token punctuation">(</span>
        <span class="token string">'ul'</span><span class="token punctuation">,</span>
        <span class="token function">_l</span><span class="token punctuation">(</span>
          <span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span>
              <span class="token string">'li'</span><span class="token punctuation">,</span>
              <span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
            <span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token comment">//React JSX的render函数</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>list<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>tiem<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token comment">//对应的render函数</span>
<span class="token comment">//React.createElement参数说明</span>
React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span><span class="token string">'div1'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>child1<span class="token punctuation">,</span>child2<span class="token punctuation">,</span>child3<span class="token operator">...</span><span class="token punctuation">)</span>
React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">id</span><span class="token operator">:</span><span class="token string">'div1'</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span>child1<span class="token punctuation">,</span>child2<span class="token punctuation">,</span>child3<span class="token operator">...</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>list<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>
      <span class="token string">'div'</span><span class="token punctuation">,</span>
      <span class="token keyword">null</span><span class="token punctuation">,</span>
      React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>
        <span class="token string">'ul'</span><span class="token punctuation">,</span>
        <span class="token keyword">null</span><span class="token punctuation">,</span>
        list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>
            <span class="token string">'li'</span><span class="token punctuation">,</span>
            <span class="token punctuation">{</span><span class="token literal-property property">key</span><span class="token operator">:</span>index<span class="token punctuation">}</span><span class="token punctuation">,</span>
            item
          <span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><hr></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Interview/browser.html" class="prev">
          浏览器相关
        </a></span> <span class="next"><a href="/Interview/miApp.html">
          小程序公众号
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.28316916.js" defer></script><script src="/assets/js/3.1b802084.js" defer></script>
  </body>
</html>
